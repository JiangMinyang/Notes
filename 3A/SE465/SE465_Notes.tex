\documentclass[10pt,usletter]{article}
\usepackage[letterpaper, hmargin=0.75in, vmargin=0.75in]{geometry}
\usepackage{graphicx}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{pgf}
\usepackage{courier}
\usepackage{amsfonts,amssymb,amsmath,amsthm,lastpage,fancyhdr,wrapfig,multirow}
\usepackage{palatino}
\usepackage{amsmath}
\usepackage{parallel,enumitem}
\usepackage{cancel}
\usepackage[english]{babel}
\usepackage{soul}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\textwidth 7.5in
\oddsidemargin -.5in
\topmargin -0.70in
\textheight 9.8in                      

\pagestyle{fancy}

%**************Fill in your ID and initials here*****************
\newcommand{\mc}[1]{\ensuremath{\mathcal{{#1}}}}
\newcommand{\mb}[1]{\ensuremath{\mathbb{{#1}}}}
\newcommand{\mf}[1]{\ensuremath{\mathfrak{{#1}}}}
\newcommand{\N}[1]{\ensuremath{\{1,\ldots,{#1}\}}}

\newcommand{\Worth}[1]{\{{#1} marks\}}
\newcommand{\Sln}{\smallskip \textbf{Solution.} }
\newcommand{\Extra}[1]{\{Extra credit: {#1} marks\}}


\setlength{\parskip}{0.15in}
\setlength{\parindent}{0in}


\newcommand{\NP}{\newpage \vspace*{-0.4in}}
\newcommand{\FP}{\vspace*{-0.6in}}
\newcommand{\tab}[1][1cm]{\hspace*{#1}}

\lstset{ %
language=Java,
basicstyle=\ttfamily\scriptsize,commentstyle=\scriptsize\itshape,showstringspaces=false,breaklines=true}


\title{\huge SE465 Notes}
\author{Minyang Jiang}
\date{\today}

\begin{document}
\maketitle
\NP
\subsection{Example 1}
\begin{lstlisting}[language=Java]
static public int findLast(int[] x, int y) {
	for (int i = x.length - 1; i > 0; i--) {
		if (x[i] == y) {
			return i;
		}
	}
	return -1'
}
@Test
public void testFindlast() {
	int[] x = new int[] {2, 3, 5};
	assertEquals(0, FindLast.findLast(x, 2));
}
\end{lstlisting}
\begin{enumerate}
\item Identify and fix the fault \\
\tab for loop condition should be $i \geq 0$
\item If possible, identify a test case that does not exercise the fault \\
\tab x is null
\item if possible, identify a test case that exercise the fault, but no error state \\
\tab findLast([1, 2, 3], 2) will return -1
\item if possible, identify a test case that results in an error, but no failure \\
\tab trying to findsomething not there ([2], 5)
\item Identify the first error state
\end{enumerate}

\subsection{Example 2}
\begin{lstlisting}[language=Python]
class LineSegment:
	def __init__(self, x1, x2):
		self.x1 = x1; self.x2 = x2;
		
	def intersect(a, b):
		return (a.x1 < b.x2) & (a.x2 > b.x1);
\end{lstlisting}
Establishing correctness of intersect:
\begin{enumerate}
\item[•] case analysis of the inputs
\end{enumerate}
Other answers
\begin{enumerate}
\item[•] execute every statement of the unit under test
\item[•] feed random inputs
\item[•] check all outputs
\item[•] check values of each clause
\end{enumerate}
rename inputs: \\
$a = a.x_1 \tab b = b.x_1$\\
$A = a.x_2 \tab B = b.x_2$
\begin{enumerate}
\item[-]assume all points are distinct\\
\item[-]assume $a < b$ (we'll check both ways when constructing test cases) \\
\item[-]assume $a < A, b < B$
\end{enumerate}
aAbB\\
abAB\\
abBA
\begin{lstlisting}[language=Python]
# run this test as 'python line-intersection-test.py'

from line_intersection import *
import unittest

class TestIntersection(unittest.TestCase):
    def test_aAbB(self):
        a = LineSegment(0,2)
        b = LineSegment(3,7)
        self.assertFalse(intersect(a,b))
        self.assertFalse(intersect(b,a))

    def test_abAB(self):
        a = LineSegment(0,4)
        b = LineSegment(3,7)
        self.assertTrue(intersect(a,b))
        self.assertTrue(intersect(b,a))

    def test_abBA(self):
        a = LineSegment(0,4)
        b = LineSegment(1,2)
        self.assertTrue(intersect(a,b))
        self.assertTrue(intersect(b,a))

    def test_equality(self):
        a = LineSegment(0,2)
        b = LineSegment(2,4)
        self.assertTrue(intersect(a,b))        # A = b
        self.assertTrue(intersect(b,a))        # B = a
        a = LineSegment(2,2)
        b = LineSegment(0,4)
        self.assertTrue(intersect(a,b))        # a = A
        self.assertTrue(intersect(b,a))        # b = B
        a = LineSegment(0,2)
        b = LineSegment(0,4)
        self.assertTrue(intersect(a,b))        # a = b
        self.assertTrue(intersect(b,a))        # b = a

if __name__ == '__main__':
    unittest.main()

\end{lstlisting}

\subsection{•}
\noindent
\fbox{
\begin{minipage}[t]{0.48\linewidth}
Static:
\begin{enumerate}
\item[-] find faults\\
example:
\begin{enumerate}
\item type checking
\item dead code analysis
\end{enumerate}
\item[-] code inspection functionality and style
\item[-] program verification
\end{enumerate}
\end{minipage}}
\hfill%
\fbox{
\begin{minipage}[t]{0.48\linewidth}
Dynamic
\begin{enumerate}
\item[-] observe failures
\item[-] must generate inputs\\
\tab what are expected outputs?
\item[-] easy to run the program
\item[-] keywords\\
\tab white-box testing\\
\tab black-box testing
\end{enumerate}
\end{minipage}}

static techninques tradeoff:
\begin{enumerate}
\item[-] exhaustive 
\item[-] subject to false positives
\end{enumerate}

words I don't like \\
\tab \st{complete testing}\\
\tab \st{exhaustive testing}\\
\tab \st{full coverage}

First big question: When should I stop testing?
\begin{enumerate}
\item when I run out of time\\
\tab open-ended explorotroy testing\\
\tab for automatic input generation
\item when I'm close enough to being exhaustive\\
\tab explored enough (all) of \\
\tab[2cm] behaviours / use cases\\
\tab[2cm] program states\\
\tab[2cm] inputs\\
\tab[2cm] statements / branches
\end{enumerate}

\huge{observability, controlability}
\subsection{Coverage}
\normalsize
\begin{enumerate}
\item[-] idea: find reduced space + cover it with test cases
\end{enumerate}
Test Requirement (TR) - an element of an artifact that soe test case must satisfy

\section*{Infeasible Test Requirements}
unreachable code
definition: coverage level - Given a set of test requirements TR and a test set T, The \underline{coverage level} is the ratio of the number of TRs satisfied by T to the size of TR.

\subsection*{Exploratory Testing}
\begin{enumerate}
\item[-] usually carried out by testers
\item[-] unscripted in general\\
\tab "Exploratory teesting is simulatneous learning, test design, and test execution"
\end{enumerate}
\subsection*{Exploratory testing is good for}
\begin{enumerate}
\item[-] simulating actual use cases (realism)
\begin{enumerate}
\item[-] diversifying testing beyond scripts
\end{enumerate}
\item[-] finding single most important bug in sortest time
\item[-] being less siloed
\item[-] evaluating aparticular risk, see if scripted tests needed
\end{enumerate}
\subsection*{Exploratory Testing Process}
\begin{enumerate}
\item start with a goal /charter
\begin{enumerate}
\item[•]"Explore the product elements"
\end{enumerate}
\item decide which area of the software to test
\item design a test (informally)
\item execute test and log bugs
\item repeat as needed
\end{enumerate}
notes: don't produce exhaustive notes
output: \begin{enumerate}
\item set of bug reports
\item test notes (possibly a judgment)
\item artifacts (input, output)
\end{enumerate}












\end{document}